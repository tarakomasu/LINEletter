手紙管理アプリ データ構成ドキュメント（letterTitle削除版）
1. 概要

このシステムは、ユーザーが作成する手紙（letters）と、それに紐づく複数の画像（letterImages）を管理するデータ構成です。
手紙のレコードはフロント側で生成したUUIDで管理し、画像レコードはデータベース側のオートインクリメントIDで管理します。

2. テーブル構成
2-1. letters テーブル

手紙の作成者情報を管理するテーブルです。

カラム名	型	主キー/制約	説明
id	uuid	PRIMARY KEY, NOT NULL	フロント生成UUID。手紙の識別子
author	text	NOT NULL	作成者名
SQL例
CREATE TABLE letters (
  id uuid PRIMARY KEY NOT NULL,
  author text NOT NULL
);

2-2. letterImages テーブル

手紙に紐づく複数の画像情報を管理するテーブルです。

カラム名	型	主キー/制約	説明
id	bigint	PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY	画像レコードの識別子（DB採番）
letterId	uuid	NOT NULL, FOREIGN KEY	letters.idへの外部キー。どの手紙に紐づくか
imageURL	text	NOT NULL	画像URL
pageNumber	int	任意	画像の順序管理用
SQL例
CREATE TABLE letterImages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  letterId uuid NOT NULL,
  imageURL text NOT NULL,
  pageNumber int,
  CONSTRAINT fk_letter FOREIGN KEY (letterId)
      REFERENCES letters(id)
      ON DELETE CASCADE
);

3. フロント側でのデータフロー

手紙UUIDを生成

const letterId = crypto.randomUUID();


lettersテーブルにINSERT

await supabase.from('letters').insert({ id: letterId, author });


画像URLの配列を作成し、letterImagesテーブルにINSERT（IDはDB採番）

const imageRecords = imageURLs.map((url, index) => ({
  letterId: letterId,
  imageURL: url,
  pageNumber: index + 1
}));
await supabase.from('letterImages').insert(imageRecords);

4. 注意点・ベストプラクティス

letterImages.letterId は NOT NULL + 外部キー で必ず手紙に紐付く

ON DELETE CASCADE により、手紙削除時に関連画像も自動削除

画像の順序管理が必要な場合は pageNumber を利用

フロント生成UUIDは衝突の可能性がほぼゼロで安全

5. 拡張例

画像ごとにコメントや作成日時を追加する場合は letterImages テーブルにカラム追加

検索性を向上させたい場合は、必要に応じてインデックスを設定