# エフェクト機能 実装方針

このドキュメントは、手紙に「エフェクト（キラキラ、イルミネーション等）」を追加する機能の実装方針を定める。

## 1. 全体アーキテクチャ：ハイブリッドアプローチ

静的な要素と動的な要素を分離して扱う「ハイブリッドアプローチ」を採用する。

- **静的レイヤー (PNG)**: 背景、便箋の柄、ユーザーが配置した動かない画像、テキストなど。ページのベースとなる部分。
- **動的レイヤー (JSON)**: アニメーションが設定されたオブジェクト、および本件の「エフェクト」。

これにより、LINE共有時のプレビュー画像(OGP)問題を解決しつつ、閲覧時の初期表示速度も向上させる。

## 2. エフェクトの実装方針

### 2.1. 基本方針

エフェクトは**JavaScriptによる動的生成**で実装する。
特に、既存の技術スタックである**Fabric.jsの標準機能（`fabric.Object`, `fabric.util.animate`等）を最大限に活用**し、アーキテクチャの一貫性を保つ。

### 2.2. 画像（GIF等）を使用しない理由

- **柔軟性の欠如**: 決まった四角い領域に決まった動きしか配置できない。
- **非インタラクティブ**: 「ユーザーが書いた文字に沿って」といった、コンテンツに合わせたエフェクト適用が不可能。
- **カスタマイズ不可**: 色、速さ、数などを後から変更できない。

## 3. データフローと保存形式

### 3.1. 座標系の考え方：「固定論理Canvas + CSSスケーリング」

レスポンシブ対応と実装のシンプルさを両立するため、以下のアプローチを取る。

1.  **基準サイズの定義**: アプリケーション全体で共通の「論理的なCanvasサイズ」（例: `1400x2048px`）を基準とする。
2.  **JSONには絶対座標を保存**: Fabric.jsの`toJSON()`をそのまま使い、論理サイズ上での**絶対座標・サイズ**をJSONに記録する。相対座標への変換計算は行わない。
3.  **CSSによるスケーリング**: 閲覧ページでは、論理サイズのCanvasをCSSの`transform`や`width: 100%`等で、表示されている背景画像にぴったり重なるように拡大・縮小させる。

これにより、複雑な座標計算を排除し、Fabric.jsの強力な状態保存/復元機能をそのまま活用する。

### 3.2. 保存処理 (`handleShare`)

1.  **静的レイヤー生成**: 動的オブジェクト（エフェクト等）を一時的に非表示にし、`canvas.toDataURL()`でベースとなるPNG画像を生成。Supabase Storageにアップロードする。
2.  **動的レイヤー生成**: 動的オブジェクトのみを`canvas.toJSON()`でシリアライズする。

### 3.3. データベーススキーマ

`letterImages`テーブルに以下のカラムを用意する。

- `imageURL` (text): 静的レイヤーであるPNG画像のURL。
- `dynamicLayerJSON` (jsonb): 動的レイヤーであるオブジェクト群のJSONデータ。

## 4. 具体的な実装例：キラキラエフェクト

Fabric.jsの機能の組み合わせで実装する。

1.  **パーティクルの作成**: 小さな`fabric.Circle`や`fabric.Path`（星形など）を複数個生成する。
2.  **アニメーション**: `fabric.util.animate`を使い、各パーティクルの`opacity`（明滅）や`left`/`top`（揺らぎ）をループ再生させる。
3.  **グループ化**: 生成したパーティクル群を`fabric.Group`で一つにまとめる。これにより、ユーザーはエフェクト全体を一つのオブジェクトとして扱える。
4.  **JSONへの保存**: この`fabric.Group`もFabric.jsオブジェクトであるため、他の動的オブジェクトと一緒に`toJSON()`で保存できる。

